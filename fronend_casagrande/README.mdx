# Algo de teoria

## Typescript

                 Â¿QuÃ© quiero describir?
                          â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                                   â”‚
     Una forma de objeto               Un tipo complejo
   (estructura con propiedades)     (union, intersection, alias)
         â”‚                                   â”‚
   â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”                       â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
   â”‚           â”‚                       â”‚           â”‚
Â¿Necesito     Â¿No necesito        Â¿Es una uniÃ³n   Â¿Es un alias simple
extenderlo o   extenderlo /        de literales?   de otro tipo?
fusionarlo?    es puntual?         â”‚               â”‚
   â”‚           â”‚                   â”‚               â”‚
   â”‚           â”‚                   â”‚               â”‚
INTERFACE      TYPE             TYPE             TYPE

ğŸ“Œ Regla de oro (sugerida por el equipo de TypeScript):

Prefiere interface para objetos que probablemente crecerÃ¡n o se extenderÃ¡n.

Usa type para cosas mÃ¡s â€œmatemÃ¡ticasâ€ (uniones, alias, intersecciones).

## Diferencia entre union e interseccion

âš¡ï¸ MetÃ¡fora rÃ¡pida:
UniÃ³n (|) â†’ menÃº de opciones â†’ eliges una.
IntersecciÃ³n (&) â†’ checklist â†’ necesitas todas.

### Ejemplo

```tsx
type Pet = "gato" | "perro" | "loro";

let myPet: Pet;

myPet = "gato";   // âœ… vÃ¡lido
myPet = "perro";  // âœ… vÃ¡lido
myPet = "pez";    // âŒ Error: "pez" no estÃ¡ en la uniÃ³n
```

```tsx
type WithId = { id: string };
type WithTimestamp = { createdAt: Date; updatedAt: Date };

type User = WithId & WithTimestamp & { name: string };

const user: User = {
  id: "123",
  createdAt: new Date(),
  updatedAt: new Date(),
  name: "Juan"
}; // âœ… vÃ¡lido porque cumple con todo
```

## Algot de Teoria de Arquitectura

bueno, vamos a la teoria, entonces un buen componente debe de tener las siguientes caracteristicas:

- Legible.
- Mantenible.
- Testeable.
- UI separada de funciones que hacen calculos de negocio.
- Bien tipeado.
- Bien comentado en lo posible con jsdoc.
- Nombres de variables en ingles (los comentarios pueden ser en espanol).
- Mapear lo que se pueda para no repetir utilizacion de funciones.

Completame la lista por fa.

Muy buena base la que armaste ğŸ’¯.
Te hago una lista mÃ¡s completa con los **principios y buenas prÃ¡cticas** que suelen aplicarse para considerar un componente â€œsÃ³lidoâ€ en React/Next (y en general en frontend moderno):

---

### âœ… CaracterÃ­sticas de un buen componente

* **Legible** â†’ cÃ³digo claro, con nombres autoexplicativos.
* **Mantenible** â†’ fÃ¡cil de modificar sin romper otras partes.
* **Testeable** â†’ diseÃ±ado para que sus funciones sean probadas en aislamiento.
* **UI separada de lÃ³gica de negocio** â†’ el componente se encarga de la vista, y la lÃ³gica de negocio se abstrae (hooks, utils, servicios).
* **Bien tipeado** â†’ tipos explÃ­citos (TypeScript) para props, estados y retornos.
* **Bien comentado** â†’ documentaciÃ³n breve y precisa (JSDoc para funciones/utilidades, comentarios claros cuando sea necesario).
* **Nombres de variables y funciones en inglÃ©s** â†’ estandarizaciÃ³n en naming (los comentarios pueden ser en espaÃ±ol).
* **Evitar duplicaciÃ³n de cÃ³digo (DRY)** â†’ mapear/extraer lÃ³gica repetida a helpers o hooks reutilizables.
* **Props claras y tipadas** â†’ evitar "props gigantes" o demasiado genÃ©ricas.
* **Single Responsibility Principle (SRP)** â†’ un componente debe hacer **una cosa bien definida**.
* **ComposiciÃ³n antes que herencia** â†’ combinar componentes pequeÃ±os en vez de hacer uno gigante con muchas responsabilidades.
* **Estados mÃ­nimos y necesarios** â†’ no duplicar estados derivados (usar props o `useMemo` cuando corresponda).
* **Pureza en la UI** â†’ evitar efectos secundarios dentro del render, delegar a hooks/acciones.
* **Accesibilidad (a11y)** â†’ usar etiquetas correctas, roles, aria-\* si aplica.
* **Consistencia en el estilo** â†’ seguir la misma convenciÃ³n de formateo y estilo (Prettier/ESLint ayudan).
* **Performance consciente** â†’ evitar renders innecesarios (`React.memo`, `useMemo`, `useCallback` cuando de verdad hace falta).
* **Errores y estados de carga manejados** â†’ nunca dejar un fetch sin `loading` y `error handling`.
* **Facilidad de testing** â†’ estructura que permita probar lÃ³gica y UI por separado.
* **SeparaciÃ³n de capas** â†’

  * UI Components â†’ solo visuales.
  * Hooks â†’ lÃ³gica compartida.
  * Utils/Services â†’ cÃ¡lculos y requests externos.
* **Escalabilidad** â†’ pensado para crecer sin tener que reescribir demasiado.
* **Consistencia en tipado y datos** â†’ usar enums, unions o constantes en vez de strings mÃ¡gicos.

---

ğŸ“Œ En pocas palabras: **componente pequeÃ±o, claro, consistente, testeable y sin lÃ³gica duplicada**.

---

Â¿Quieres que te arme una **checklist prÃ¡ctica** (con Ã­tems de verificaciÃ³n que puedas usar al revisar cada componente de tu proyecto)?

## Trabajo a seguir con el componete de mascotas

- Tener en cuenta que es un array de opciones y la forma en que funciona el layout para colcar los filtros en categorias, 
es que solo se escoje uno por categoria, pero las mascotas es un array, falta la opcion de sin mascotas y tener cuadiad o ya que 
las funciones de obtencion del state inical para los pets no esta funcionando bien